<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd">

	<!--
		**** Beans useful for multiple mappers (particularly in chained
		mappers) ****
	-->

	<!-- Results combiner - just returns the first non-null value -->
	<bean id="nonNullResultsCombiner"
		class="org.eurekastreams.server.persistence.mappers.chained.NonNullResultsCombiner" />

	<bean name="hashTagExtractor"
		class="org.eurekastreams.server.domain.strategies.HashTagExtractor" />

	<bean name="activityContentExtractor"
		class="org.eurekastreams.server.persistence.mappers.stream.ActivityContentExtractor" />
		
	<bean name="ignoredCacheKeySuffixTransformer" 
		class="org.eurekastreams.server.persistence.mappers.cache.IgnoredCacheKeySuffixTransformer" />
	
	<bean id="toStringCacheKeySuffixTransformer" 
		class="org.eurekastreams.server.persistence.mappers.cache.ToStringCacheKeySuffixTransformer" />
	
	<bean id="collectionCombiner" class="org.eurekastreams.server.persistence.mappers.chained.CollectionCombiner" />	
	
	<bean id="getOrderedPersonStreamsByPersonIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetOrderedPersonStreamsByPersonIdDbMapper" />
	
	<bean id="removeCachedPersonModelViewCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.RemoveCachedPersonModelViewCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>
	
	<!-- ========== CACHE KEYS ========== -->
	
	<util:constant id="CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" />
	<util:constant id="CacheKeys.LIKERS_BY_RESOURCE_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKERS_BY_RESOURCE_ID" />
	<util:constant id="CacheKeys.LIKERS_BY_ACTIVITY_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKERS_BY_ACTIVITY_ID" />
	
	<!--
		Mapper to get the hash tags from the database - insert if not already
		in the database
	-->
	<bean id="getHashTagsFromDatabaseMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!-- Partial database mapper -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.PartialHashTagDbMapper" />
		</constructor-arg>

		<constructor-arg>
			<!--
				Hashtag generation mapper to create new ones if not found in the
				database
			-->
			<bean
				class="org.eurekastreams.server.persistence.mappers.HashTagBuilderMapper" />
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Database refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.HashTagDbRefreshStrategy" />
		</constructor-arg>
	</bean>
	<!-- ****  **** -->

	<!--
		Wire up the entity updaters for person, domain group, organization -
		handles onPostUpdate, onPostPersist
	-->
	<bean
		class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject">
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.CacheInitializer" />
		</property>
		<property name="targetMethod" value="wireCacheUpdaters" />
		<property name="arguments">
			<list>
				<ref bean="domainGroupEntityCacheUpdater" />
				<ref bean="organizationEntityCacheUpdater" />
				<ref bean="personEntityCacheUpdater" />
			</list>
		</property>
	</bean>

	<bean id="getAllPluginsMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetAllPluginsMapper" />

	<bean id="getFeedSubscriptionsByEntity"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedSubscriptionsByEntity" />

	<bean id="getFeedSubscriberOrCreateMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedSubscriberOrCreateMapper" />

	<bean id="getFeedByUrlOrCreateMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedByUrlOrCreateMapper" />

	<bean id="getRefreshableFeedsMapper"
		class="org.eurekastreams.server.persistence.mappers.GetRefreshableFeedsMapper" />

	<bean id="setRefreshableFeedsAsPendingMapper"
		class="org.eurekastreams.server.persistence.mappers.SetRefreshableFeedsAsPending" />

	<bean id="deleteByIdMapper"
		class="org.eurekastreams.server.persistence.mappers.DeleteByIdMapper" />

	<bean id="addBufferedActivitiesToCache"
		class="org.eurekastreams.server.persistence.mappers.cache.AddBufferedActivitiesToCache">
		<constructor-arg ref="bulkActivitiesMapper" />
		<constructor-arg ref="memcachedCache" />
		<constructor-arg ref="getPersonIdsFollowingActivityDestinationStreamMapper" />
		<constructor-arg ref="postActivityUpdateStreamsByActorMapper" />
	</bean>

	<bean id="jpaFeedReaderMapper" class="org.eurekastreams.server.persistence.FeedReaderMapper"></bean>

	<bean id="searchPeopleAndGroupsByPrefixMapper"
		class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
		<constructor-arg value="7" /> <!-- default max results -->
		<constructor-arg ref="groupPersonSearchRequestBuilder" />
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg value="false" />
	</bean>

	<bean id="searchGroupsByPrefixMapper"
		class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
		<constructor-arg value="7" /> <!-- default max results -->
		<constructor-arg ref="groupPersonSearchRequestBuilder" />
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg value="true" />
	</bean>

	<bean id="getPendingDomainGroupsForOrg"
		class="org.eurekastreams.server.persistence.mappers.GetPendingDomainGroupsForOrg">
		<constructor-arg>
			<ref bean="organizationHierarchyCache" />
		</constructor-arg>
		<property name="getPeopleByIdsMapper" ref="getPersonsByIdsMapper" />
	</bean>

	<bean id="activityOrCombiner"
		class="org.eurekastreams.server.persistence.mappers.chained.ListColliderAdapter">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.service.actions.strategies.activity.OrSortedListCollider" />
		</constructor-arg>
		<constructor-arg value="10000" />
	</bean>


	<bean id="getOrganizationLeaderIdsByOrgId" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
						<constructor-arg>
							<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_LEADERS_BY_ORG_ID" />
						</constructor-arg>
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.db.GetOrganizationLeaderIdsByOrgId" />
		</constructor-arg>
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg>
					<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_LEADERS_BY_ORG_ID" />
				</constructor-arg>
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>
	

	<bean id="findByIdMapper"
		class="org.eurekastreams.server.persistence.mappers.FindByIdMapper">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_TREE_DTO" 
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_SECURITY_BY_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /> 
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />	
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />	
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /> 
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />        
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_SHORT_NAME"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_PARENTS_RECURSIVE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_RECURSIVE_CHILDREN"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />   
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_COORDINATORS_BY_ORG_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />                            
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />    
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID"
            class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />        
                           
	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_IDS_FOR_ORG_BY_SHORTNAME_RECURSIVE"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		
	<bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.EVERYONE_ACTIVITY_IDS"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITIES_BY_FOLLOWING"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />        
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />   
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />                   

	<!--
		Mapper that goes to cache for the popular hashtags for a stream.  If it exists, it checks how long ago it was generated. 
		If it was too long ago, it throws the cached value away and falls back to the database, then stores that result in cache.
	 -->
	<bean id="findPopularHashTagsForStreamMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		
		<!-- CACHE COMPONENT -->
		<constructor-arg>
			
			<!-- Cache mapper isn't partial results - wrap it -->
			<bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
				
					<!-- Get the value from cache, and check to make sure it's not too old
-->
					<bean class="org.eurekastreams.server.persistence.mappers.StreamPopularHashTagsMapper">		
						
						<!-- Use the reusable single-value cache mapper to get the value -->
						<constructor-arg>
							<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
								<!-- Transformer from stream populator hash tags request to cache key suffix -->
	
								<!-- Cache Key Prefix -->				
								<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />

								<constructor-arg>
									<bean class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
								</constructor-arg>
								
								<property name="cache" ref="memcachedCache" />
							</bean>
						</constructor-arg>
						
						<!-- Number of minutes that we keep popular hashtags in cache -->
						<constructor-arg value="${eureka.stream.popularhashtags.cachetimeoutinminutes}" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		
		<!-- DATABASE COMPONENT -->
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean class="org.eurekastreams.server.persistence.mappers.db.StreamPopularHashTagsDbMapper">
			
				<!-- Number of minutes to look back for popular hashtags -->
				<constructor-arg value="${eureka.stream.popularhashtags.activitywindowinminutes}" />
				
				<!-- Max number of hashtags to return -->
				<constructor-arg value="${eureka.stream.popularhashtags.count}" />
			</bean>
		</constructor-arg>

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		
		<!-- CACHE REFRESHER -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<!-- Cache Key Prefix -->				
				<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />

				<!-- Cache key suffix transformer -->
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
				</constructor-arg>

				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>



    <bean id="findPopularHashTagsForAllGroupsJoinedMapper"
        class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        
        <!-- CACHE COMPONENT -->

        <constructor-arg>
            <!-- Cache mapper isn't partial results - wrap it -->
                            <bean
                                class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                                <constructor-arg>
                                    <bean
                                        class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
                                </constructor-arg>
                                <constructor-arg
                                    ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />
                               <constructor-arg value="False" />
                                <property name="cache" ref="memcachedCache" />
                             </bean>
         </constructor-arg>
        <!-- DATABASE COMPONENT -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.MultiRequestMapperWrapper">
                    <constructor-arg>
                         <ref bean="findPopularHashTagsForStreamMapper" />
                    </constructor-arg>
            </bean>
        </constructor-arg>

        <constructor-arg ref="collectionCombiner" />
        
        <!-- CACHE REFRESHER -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.NullCacheRefresher" />
        </constructor-arg>
    </bean>

	<bean id="bulkActivitySecurityMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_SECURITY_BY_ID" />
				<constructor-arg value="False" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.db.BulkActivitySecurityDbMapper" />
				</constructor-arg>
		
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.BulkDeletedActivitySecurityMapper" />
				</constructor-arg>
		
				<constructor-arg ref="collectionCombiner" />
		
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.cache.NullCacheRefresher" />
		        </constructor-arg>
			</bean>		
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.BulkActivitySecurityRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getUserStreamsMapper" class="org.eurekastreams.server.persistence.mappers.db.GetUserStreamsDbMapper" />


	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="bulkActivityStreamsMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.BulkActivityStreamsDbMapper">
					<property name="maxItems" value="10000" />
			</bean>

		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID" />
				<!-- Cache Key Prefix -->				
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>
	
	<!-- Mapper to get the org tree -->
	<bean id="getOrganizationTreeDTOMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		
		<!-- Cache mapper -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
						<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_TREE_DTO" />
						<constructor-arg ref="ignoredCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		
		<!-- Fall-back mapper -->
		<constructor-arg>
			<!-- Org tree builder - uses other decorated partial response domain mappers -->
			<bean class="org.eurekastreams.server.persistence.mappers.GetOrganizationTreeDTO">
				<constructor-arg ref="getAllOrganizationIdsDbMapper" />
				<constructor-arg ref="getOrganizationsByIdsMapper" />
			</bean>
		</constructor-arg>
		
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
				
		<!-- Store the DTO back in cache -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_TREE_DTO" />
				<constructor-arg ref="ignoredCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

    <!-- Mapper to get people ids by account ids -->
    <bean id="getPeopleIdsByAccountIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="accountId" />
                <constructor-arg value="org.eurekastreams.server.domain.Person" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedSingleItemCollectionCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <!-- Mapper to get people ids by open social ids -->
    <bean id="getPeopleIdsByOpenSocialIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="openSocialId" />
                <constructor-arg value="org.eurekastreams.server.domain.Person" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedSingleItemCollectionCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <!-- Mapper to get organization ids by short name -->
    <bean id="getOrganizationIdsByShortNamesMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_SHORT_NAME" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="shortName" />
                <constructor-arg value="org.eurekastreams.server.domain.Organization" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedSingleItemCollectionCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_SHORT_NAME" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <!-- Mapper to get group ids by short name -->
    <bean id="getDomainGroupIdsByShortNamesMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="shortName" />
                <constructor-arg value="org.eurekastreams.server.domain.DomainGroup" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedSingleItemCollectionCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>

	<!-- Mapper to get person id by account id - wraps getPeopleIdsByAccountIds - throws exception when not found -->
	<bean id="getPersonIdByAccountIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPeopleIdsByAccountIdsMapper" />
		<constructor-arg value="true" />
	</bean>

	<!-- Mapper to get people by account ids -->
	<bean id="getPeopleByAccountIdsMapper" class="org.eurekastreams.server.persistence.mappers.GetItemsByPointerIdsMapper">
		<!-- Mapper to get people ids from account ids -->
		<constructor-arg ref="getPeopleIdsByAccountIdsMapper" />
		
		<!-- mapper to look up people by ids -->
		<constructor-arg ref="getPersonsByIdsMapper" />
	</bean>

	<!-- Mapper to get person model view by account id - wraps getPeopleByAccountIdsMapper - throws exception when not found -->
	<bean id="getPersonByAccountIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPeopleByAccountIdsMapper" />
		<constructor-arg value="true" />
	</bean>
	
	<!-- Mapper to get person model view by account id - wraps getPeopleByAccountIdsMapper - returns null when not found -->
    <bean id="getPersonByAccountIdMapperAllowNullResult" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="getPeopleByAccountIdsMapper" />
        <constructor-arg value="false" />
    </bean>

	<bean id="parentOrgActivityIdMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
						<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
					
						<!-- Cache Key Prefix -->				
						<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_IDS_FOR_ORG_BY_SHORTNAME_RECURSIVE" />
						
						<!-- Transformer from org short name to org short name -->
						<constructor-arg>
							<bean class="org.eurekastreams.server.persistence.mappers.cache.LowerCaseCacheKeySuffixTransformer" />
						</constructor-arg>
						
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.OrgActivityIdsDbMapper">
				<property name="descendantOrganizationStrategy" ref="descendantOrgStrategy" />
			</bean>
		</constructor-arg>

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.OrgActivityIdsRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="parentOrgActivityIdMapper_FORCE_REFRESH"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg ref="nullResultPartialMapper" />

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.OrgActivityIdsDbMapper">
				<property name="descendantOrganizationStrategy" ref="descendantOrgStrategy" />
			</bean>
		</constructor-arg>

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.OrgActivityIdsRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="findSystemSettings"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!--
				Wrap the System Settings cache mapper with a partial mapper wrapper
			-->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<!-- Cache mapper to get the system settings -->
					<bean
						class="org.eurekastreams.server.persistence.mappers.cache.FindSystemSettingsCacheDomainMapperImpl">
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>

		<constructor-arg ref="findSystemSettingsFromDatabase" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.RefreshSystemSettingsCacheMapperImpl">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>


	<bean id="findSystemSettingsFromDatabase"
		class="org.eurekastreams.server.persistence.mappers.db.FindSystemSettingsDbDomainMapperImpl">
		<constructor-arg ref="headerContentTemplate" />
		<constructor-arg ref="footerContentTemplate" />
		<!--
			Mapper to get the system settings straight from the database - needed
			for updating it.
		-->
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>
	
	<bean id="getTutorialVideos" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
		                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS" />
		                <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		                <property name="cache" ref="memcachedCache" />
		            </bean>
		        </constructor-arg>
		    </bean>
	    </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetTutorialVideosDbMapper" />
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
		        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS" />
		        <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		        <property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
    </bean>
    
    <bean id="getAppDataDTO" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID" />
                        <constructor-arg ref="getAppDataRequestToSuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetAppDataDTODbMapper">
                <constructor-arg ref="jpaAppDataMapper"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID" />
                <constructor-arg ref="getAppDataRequestToSuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean> 
    
    <bean id="getThemeCssByUuid" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.ThemeCssDbMapper">
                <constructor-arg value="/org/eurekastreams/server/conf/schema/css.xslt"/>
                <constructor-arg ref="getThemeXmlUrlByUuidDbMapper"/>
                <constructor-arg>
		            <bean class="org.eurekastreams.server.service.actions.strategies.URLFetcher" />
		        </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>
    
    <bean id="getThemeCssByUuid_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.ThemeCssDbMapper">
                <constructor-arg value="/org/eurekastreams/server/conf/schema/css.xslt"/>
                <constructor-arg ref="getThemeXmlUrlByUuidDbMapper"/>
                <constructor-arg>
                    <bean class="org.eurekastreams.server.service.actions.strategies.URLFetcher" />
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>    
    
    <bean id="getThemeVersionByUuid" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetThemeVersionByUuidDbMapper">
                <constructor-arg ref="getThemeCssByUuid"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>  
    
    <!-- This mapper will force refresh of BOTH theme version AND theme css as it is config'd with the 
    force refresh version of getThemeCssByUuid mapper.-->
    <bean id="getThemeVersionByUuid_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetThemeVersionByUuidDbMapper">
                <constructor-arg ref="getThemeCssByUuid_FORCE_REFRESH"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>      
    
    <bean id="getPersonPagePropertiesById" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPersonPagePropertiesByIdDbMapper">
                <constructor-arg ref="findByIdMapper" />
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.PersonToPersonPagePropertiesTransformer"/>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean> 
    
    <bean id="getPersonPagePropertiesById_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <constructor-arg ref="nullResultPartialMapper"/>
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPersonPagePropertiesByIdDbMapper">
                <constructor-arg ref="findByIdMapper" />
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.PersonToPersonPagePropertiesTransformer"/>
                </constructor-arg>
            </bean>
        </constructor-arg>
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>      
    
    <bean id="getAppDataRequestToSuffixTransformer" class="org.eurekastreams.server.persistence.mappers.cache.GetAppDataRequestToSuffixTransformer"/>   
    
    <bean id="saveOrganizationCoordinatorIdsToCache"
		class="org.eurekastreams.server.persistence.mappers.cache.SaveOrganizationCoordinatorIdsToCache">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="saveDomainGroupCoordinatorsListToCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.SaveDomainGroupCoordinatorsListToCache">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="findLinkInformationByUrlMapper"
		class="org.eurekastreams.server.persistence.mappers.FindLinkInformationByUrl">
		<property name="queryOptimizer" ref="queryOptimizer" />
		<property name="expirationInMilliseconds" value="7200000" />
	</bean>

	<bean id="insertStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.InsertStarredActivity">
		<constructor-arg ref="getStarredActivityIds" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.DeleteStarredActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="insertLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.InsertLikedActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.DeleteLikedActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getEveryoneActivityDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetEveryoneActivityDbMapper">
	</bean>
	<bean id="refreshFollowedByActivitiesCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.RefreshFollowedByActivitiesCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>
	<bean id="getFollowedByActivitiesDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFollowedByActivitiesDbMapper">
		<constructor-arg ref="followedActivityIdsLoader" />
		
		<!-- Limit how many following activity ids we get from the database -->
		<constructor-arg value="10000" />
	</bean>

	<bean id="getFollowedByActivities"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!-- Wrap the cache mapper with a partial mapper wrapper -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
						<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITIES_BY_FOLLOWING" />
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>

		<!-- Database mapper to fall back on if not found in cache -->
		<constructor-arg ref="getFollowedByActivitiesDbMapper" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<!-- Cache refresher -->
		<constructor-arg ref="refreshFollowedByActivitiesCacheMapper" />
	</bean>
	
	<bean id="getOrganizationsByIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_ID" />
				<constructor-arg value="False" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getOrganizationsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="organizationCacheRefresher"/>                        
    </bean>
	
	<bean id="getOrganizationsByIdsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getOrganizationsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="organizationCacheRefresher"/>                        
    </bean>
    
    <bean id="getParentOrgIdsRecursiveByOrgIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
						<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_PARENTS_RECURSIVE" />
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getParentOrgIdsRecursiveByOrgIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="orgRecursiveParentOrgIdRefresher" />
    </bean>
    
	<bean id="getParentOrgIdsRecursiveByOrgIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
	    <!-- Cache Mapper -->
		<constructor-arg ref="nullResultPartialMapper"/>
		<!-- Database mapper to fall back on if not found in cache -->
		<constructor-arg ref="getParentOrgIdsRecursiveByOrgIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="orgRecursiveParentOrgIdRefresher" />
	</bean> 
    
    <bean id="getChildOrgIdsRecursiveByOrgIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getChildOrgIdsRecursiveByOrgIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
		<constructor-arg ref="getChildOrgIdsRecursiveByOrgIdCacheRefresher"/>
    </bean>
    
    <bean id="getChildOrgIdsRecursiveByOrgIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getChildOrgIdsRecursiveByOrgIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getChildOrgIdsRecursiveByOrgIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getChildOrgIdsRecursiveByOrgIdCacheRefresher"/>
    </bean>    
    
    <bean id="getChildOrgIdsRecursiveByOrgIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_RECURSIVE_CHILDREN" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>  
    
    <bean id="getChildOrgIdsRecursiveByOrgIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_RECURSIVE_CHILDREN" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>                 
		
	<bean id="getGroupCoordinatorIdsByGroupIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheRefresher"/>                      
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheRefresher"/>                       
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
		        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID" />
		        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
		        <property name="cache" ref="memcachedCache" />
		    </bean>
	    </constructor-arg>
    </bean> 
    
   <bean id="getOrderedCommentIdsByActivityIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdCacheRefresher"/>                       
    </bean>
    
    <bean id="getOrderedCommentIdsByActivityIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="getOrderedCommentIdsByActivityIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>    
	
	<bean id="getFollowedByActivities_FORCE_REFRESH"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg ref="nullResultPartialMapper" />

		<!-- Database mapper to fall back on if not found in cache -->
		<constructor-arg ref="getFollowedByActivitiesDbMapper" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<!-- Cache refresher -->
		<constructor-arg ref="refreshFollowedByActivitiesCacheMapper" />
	</bean>
	
	<bean id="getGroupsByIdsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="groupCacheRefresher"/>                        
    </bean> 
    
    <bean id="getGroupsByIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getGroupsByIdsCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="groupCacheRefresher"/>                        
    </bean>     
    
    <bean id="getGroupsByIdsCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID" />
        <!-- Is list of lists flag -->
        <constructor-arg value="False" />
        <property name="cache" ref="memcachedCache" />
    </bean>        
	
	<bean id="getFollowedGroupIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheRefresher" />                       
    </bean>
    
    <bean id="getFollowedGroupIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheRefresher" />                       
    </bean>   
    
    <bean id="getFollowedGroupIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <bean id="getFollowedGroupIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowerPersonIdsForGroupByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheRefresher"/>                       
    </bean>    
    
    <bean id="getFollowerPersonIdsForGroupByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheRefresher"/>                       
    </bean> 
    
    <bean id="getFollowerPersonIdsForGroupByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>         
        
    <bean id="getFollowerPersonIdsForGroupByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
	

    <bean id="getFollowedPersonIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean>
        
    <bean id="getFollowedPersonIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheRefresher"/>                        
    </bean> 
    
    <bean id="getFollowedPersonIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowedPersonIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>             
    
    <bean id="getFollowerPersonIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean>
        
    <bean id="getFollowerPersonIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean> 
    
    <bean id="getFollowerPersonIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowerPersonIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>        

    <bean id="getPersonsByIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getPersonsByIdsCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getPersonsByIdsDBMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="personCacheRefresher"/>                        
    </bean>
    
	<!-- Mapper to get a person by id, throwing exception when not found -->
	<bean id="getPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPersonsByIdsMapper" />
		<constructor-arg value="true" />
	</bean>
    
    <bean id="getPersonsByIdsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getPersonsByIdsDBMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="personCacheRefresher"/>                        
    </bean>    
    
    <bean id="getPersonsByIdsCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID" />
        <!-- Is list of lists flag -->
        <constructor-arg value="False" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="personCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiRefreshCacheRefreshStrategy">
        <constructor-arg>
            <list>
                <ref local="personByIdRefresher" />
                <ref local="personByAccountIdRefresher" />
                <ref local="personByOpenSocialIdRefresher" />
            </list>
        </constructor-arg>
    </bean>       
    
    <bean id="personByIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="passThroughTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />        
    </bean>     
    
    <bean id="personByAccountIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="personToAccountIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>   
    
    <bean id="personByOpenSocialIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="personToOpenSocialIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean> 
    
    <bean id="groupCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiRefreshCacheRefreshStrategy">
        <constructor-arg>
            <list>
                <ref local="groupByIdRefresher" />
                <ref local="groupByShortNameRefresher" />
            </list>
        </constructor-arg>
    </bean>  
    
    <bean id="groupByIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="passThroughTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>
    
    <bean id="groupByShortNameRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="groupToShortNameTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean> 
        
    <bean id="organizationCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiRefreshCacheRefreshStrategy">
        <constructor-arg>
            <list>
                <ref local="organizationByIdRefresher" />
                <ref local="organizationByShortNameRefresher" />
            </list>
        </constructor-arg>
    </bean>
    
    <bean id="orgRecursiveParentOrgIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
		<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_PARENTS_RECURSIVE" />
		<constructor-arg ref="toStringCacheKeySuffixTransformer" />
		<property name="cache" ref="memcachedCache" />
	</bean>
    
    <bean id="organizationByIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="passThroughTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>
    
    <bean id="organizationByShortNameRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORGANIZATION_BY_SHORT_NAME" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="organizationToShortNameTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>    
    
    <bean id="modelViewToIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.ModelViewToIdTransformer" />
    
    <bean id="organizationToShortNameTransformer" class="org.eurekastreams.server.persistence.mappers.cache.OrganizationToShortNameTransformer" />    
    
    <bean id="groupToShortNameTransformer" class="org.eurekastreams.server.persistence.mappers.cache.GroupToShortNameTransformer" />    
    
    <bean id="personToAccountIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PersonToAccountIdTransformer" />
    
    <bean id="personToOpenSocialIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PersonToOpenSocialIdTransformer" />
    
    <bean id="passThroughTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PassThroughTransformer" />	
    
    <bean id="nullResultPartialMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.NullMapper">
            </bean>
        </constructor-arg>
    </bean>
    
    <bean id="personEntityCacheUpdater" class="org.eurekastreams.server.persistence.mappers.cache.PersonEntityCacheUpdater">
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="organizationEntityCacheUpdater" class="org.eurekastreams.server.persistence.mappers.cache.OrganizationEntityCacheUpdater">
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="domainGroupEntityCacheUpdater" class="org.eurekastreams.server.persistence.mappers.cache.DomainGroupEntityCacheUpdater">
        <property name="cache" ref="memcachedCache" />
    </bean>    

	<bean id="orgParentHierarchyCacheCleaner"
		class="org.eurekastreams.server.persistence.mappers.cache.OrgParentHierarchyCacheCleaner">
		<property name="cache" ref="memcachedCache" />
		<property name="getRecursiveParentOrgIdsMapper" ref="getParentOrgIdsRecursiveByOrgIdMapper" />
	</bean>

	<bean id="getStreamScopeById"
		class="org.eurekastreams.server.persistence.mappers.GetStreamScopeById" />

	<bean id="getStreamScopeProxyById"
		class="org.eurekastreams.server.persistence.mappers.GetStreamScopeProxyById" />		

	<bean id="followedActivityIdsLoader"
		class="org.eurekastreams.server.persistence.mappers.cache.FollowedActivityIdsLoaderImpl" />
		
	<bean id="activityIdSearchPageFetcherFactory"
		class="org.eurekastreams.server.search.stream.ActivityIdSearchPageFetcherFactory">
		<constructor-arg value="5" />
	</bean>

	<bean id="luceneActivityDataSource"
		class="org.eurekastreams.server.service.actions.strategies.activity.datasources.LuceneDataSource">
		<!-- DataSource for searching activities -->

		<constructor-arg>
			<bean
				class="org.eurekastreams.commons.search.ProjectionSearchRequestBuilder">
				<property name="resultFields">
					<list>
						<value>id</value>
					</list>
				</property>
				<property name="resultTypes">
					<list>
						<value>org.eurekastreams.server.domain.stream.Activity
						</value>
					</list>
				</property>
				<property name="queryParserBuilder">
					<bean class="org.eurekastreams.commons.search.QueryParserBuilder">
						<constructor-arg value="content" />
						<constructor-arg>
							<bean
								class="org.eurekastreams.commons.search.analysis.HashTagTextStemmerSearchAnalyzer" />
						</constructor-arg>
						<constructor-arg value="AND" />
					</bean>
				</property>
				<property name="advancedQueryParserBuilder">
					<bean class="org.eurekastreams.commons.search.QueryParserBuilder">
						<constructor-arg value="content" />
						<constructor-arg>
							<bean
								class="org.eurekastreams.commons.search.analysis.HashTagTextStemmerSearchAnalyzer" />
						</constructor-arg>
						<constructor-arg value="AND" />
					</bean>
				</property>
				<property name="resultTransformer">
					<bean
						class="org.eurekastreams.commons.hibernate.SingleFieldResultTransformer">
						<property name="fieldName" value="id" />
					</bean>
				</property>
			</bean>
		</constructor-arg>
		<constructor-arg>
			<bean
				class="org.eurekastreams.commons.search.ProjectionSearchRequestBuilder">
				<property name="resultFields">
					<list>
						<value>id</value>
					</list>
				</property>
				<property name="resultTypes">
					<list>
						<value>org.eurekastreams.server.domain.stream.Activity
						</value>
					</list>
				</property>
				<property name="queryParserBuilder">
				    <bean id="unstemmedActivityResultsQueryBuilder" class="org.eurekastreams.commons.search.QueryParserBuilder"
				        scope="prototype">
				        <constructor-arg value="_hibernate_class" />
				        <constructor-arg>
				            <bean class="org.apache.lucene.analysis.WhitespaceAnalyzer" />
				        </constructor-arg>
				        <constructor-arg value="AND" />
				    </bean>
				</property>
				<property name="resultTransformer">
					<bean
						class="org.eurekastreams.commons.hibernate.SingleFieldResultTransformer">
						<property name="fieldName" value="id" />
					</bean>
				</property>
			</bean>
		</constructor-arg>
		<constructor-arg>
			<map>
				<entry key="keywords" value="content" />
				<entry key="authoredBy" value="author" />
				<entry key="fromApp" value="appId" />
			</map>
		</constructor-arg>
		<constructor-arg>
        	<map>
				<entry key="authoredBy">
					<bean 
                       class="org.eurekastreams.server.service.actions.strategies.activity.datasources.AuthoredByPersistenceRequestTransformer">
                       <constructor-arg ref="getPersonIdByAccountIdMapper" />   
                       <constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
                    </bean>
				</entry>
				<entry key="fromApp">
					<bean class="org.eurekastreams.server.service.actions.strategies.activity.datasources.AppSourcePersistenceRequestTransformer" />
				</entry>
			</map>
		</constructor-arg>		
		<constructor-arg value="10000" />
	</bean>

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_BY_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="bulkActivitiesMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_BY_ID" />
				<constructor-arg value="False" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.stream.BulkActivitiesDbMapper">
				<constructor-arg ref="getPersonByAccountIdMapper" /> 
				<constructor-arg ref="getPeopleByAccountIdsMapper" />
				<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
				<constructor-arg ref="getOrderedCommentIdsByActivityIdMapper" />
				<constructor-arg ref="getCommentsById" />
			</bean>
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.BulkActivityRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getOrganizationCoordinatorIdsByOrganizationIdDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetOrganizationCoordinatorIdsByOrganizationIdDbMapper" />


	<bean id="getPrivateGroupsByUserIdSource"
		class="org.eurekastreams.server.persistence.mappers.composite.GetPrivateGroupsByUserId">
		<constructor-arg ref="getPrivateGroupIdsCoordinatedByPersonMapper" />
		<constructor-arg ref="getOrgIdsDirectlyCoordinatedByPerson" />
		<constructor-arg ref="organizationHierarchyCache" />
		<constructor-arg ref="getPrivateGroupIdsUnderOrganizationsFromDB" />
	</bean>

	<bean id="baseGetPrivateGroupsByUserIdCacheHandling" abstract="true">
		<constructor-arg>
			<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PRIVATE_GROUP_IDS_VIEWABLE_BY_PERSON_AS_COORDINATOR" />
		</constructor-arg>
		<constructor-arg ref="toStringCacheKeySuffixTransformer" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPrivateGroupsByUserId" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg ref="getPrivateGroupsByUserIdSource" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
	    </constructor-arg>       
	</bean>
	
	<bean id="getPrivateGroupsByUserId_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg ref="nullResultPartialMapper" />
		<!-- Database mapper -->
		<constructor-arg ref="getPrivateGroupsByUserIdSource" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
	    </constructor-arg>       
	</bean>


	<bean id="addPrivateGroupIdToCachedCoordinatorAccessList"
		class="org.eurekastreams.server.persistence.mappers.cache.AddPrivateGroupIdToCachedCoordinatorAccessList">
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPrivateGroupIdsUnderOrganizationsFromDB"
		class="org.eurekastreams.server.persistence.mappers.db.GetPrivateGroupIdsUnderOrganizations" />

	<bean id="getOrgIdsDirectlyCoordinatedByPersonFromDB"
		class="org.eurekastreams.server.persistence.mappers.db.GetOrgIdsDirectlyCoordinatedByPerson" />

	<bean id="getOrgIdsDirectlyCoordinatedByPerson" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
						<constructor-arg ref="CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" />
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg ref="getOrgIdsDirectlyCoordinatedByPersonFromDB" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
	        	<constructor-arg ref="CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" />
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>


	<bean id="getOrgCoordinators"
		class="org.eurekastreams.server.persistence.mappers.GetOrgCoordinators">
		<property name="cache" ref="memcachedCache" />
		<constructor-arg ref="getOrganizationCoordinatorIdsByOrganizationIdDbMapper" />
	</bean>

	<bean id="getRecursiveOrgCoordinators"
		class="org.eurekastreams.server.persistence.mappers.GetRecursiveOrgCoordinators">
		<constructor-arg ref="organizationHierarchyCache" />
		<constructor-arg ref="getOrgCoordinators" />
		<constructor-arg type="java.lang.Boolean" value="true" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="memcachedCache" />
	</bean>

	<bean id="getRecursiveOrgCoordinatorsDownTree"
		class="org.eurekastreams.server.persistence.mappers.GetRecursiveOrgCoordinators">
		<constructor-arg ref="organizationHierarchyCache" />
		<constructor-arg ref="getOrgCoordinators" />
		<constructor-arg value="false" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="memcachedCache" />
	</bean>

	<bean id="getAllPersonIdsWhoHaveGroupCoordinatorAccess"
		class="org.eurekastreams.server.persistence.mappers.GetAllPersonIdsWhoHaveGroupCoordinatorAccess">
		<constructor-arg ref="getGroupCoordinatorIdsByGroupIdMapper" />
		<constructor-arg ref="getGroupsByIdsMapper" />
		<constructor-arg ref="bulkOrganizationsByShortNameMapper" />
		<constructor-arg ref="getRecursiveOrgCoordinators" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
	</bean>

	<bean id="commentDeletePropertyStrategy"
		class="org.eurekastreams.server.persistence.strategies.CommentDeletePropertyStrategy">
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<constructor-arg ref="getRecursiveOrgCoordinators" />
	</bean>

	<bean id="activityDeletePropertyStrategy"
		class="org.eurekastreams.server.persistence.strategies.ActivityDeletePropertyStrategy">
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<constructor-arg ref="getRecursiveOrgCoordinators" />
	</bean>

	<bean id="personQueryStrategy"
		class="org.eurekastreams.server.persistence.strategies.PersonQueryStrategy" />

	<bean id="domainGroupQueryStrategy"
		class="org.eurekastreams.server.persistence.strategies.DomainGroupQueryStrategy" />

	<bean id="bulkPeopleByOpenSocialIdMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetPeopleByOpenSocialIds">
		<property name="bulkPeopleMapper" ref="getPersonsByIdsMapper" />
		<property name="idsByStringsMapper" ref="getPeopleIdsByOpenSocialIdsMapper" />
	</bean>

	<bean id="bulkOrganizationsByShortNameMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetOrganizationsByShortNames">
		<property name="bulkOrganizationsMapper" ref="getOrganizationsByIdsMapper" />
		<property name="idsByStringsMapper" ref="getOrganizationIdsByShortNamesMapper" />
	</bean>

	<bean id="bulkDomainGroupsByShortNameMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetDomainGroupsByShortNames">
		<property name="bulkDomainGroupsMapper" ref="getGroupsByIdsMapper" />
		<property name="idsByStringsMapper" ref="getDomainGroupIdsByShortNamesMapper" />
	</bean>
	
    <bean id="getCommentsById"
        class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <constructor-arg>
            <bean
                class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg
                    ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>

        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetCommentsByIdsDbMapper">
                <constructor-arg ref="commentDTOPopulator" />
            </bean>
        </constructor-arg>

        <constructor-arg ref="collectionCombiner" />

        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
                <!-- Prefix -->
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID" />
                <!-- Suffix Transformer -->
                <constructor-arg ref="modelViewToIdTransformer"/>
                 <!-- Value Transformer -->
                <constructor-arg ref="passThroughTransformer"/>
                <!-- Cache -->
                <constructor-arg ref="memcachedCache" />        
            </bean>
        </constructor-arg>
    </bean>	

	<bean id="deleteActivityComment"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivityComment">
		<constructor-arg ref="getCommentsById" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivity">
		<constructor-arg ref="bulkActivitiesMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteActivityCacheUpdateDAO"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivityCacheUpdate">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForGroupByIdMapper" />
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getPeopleWhoLikedActivity" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPersonIdsWithStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.GetPersonIdsWithStarredActivity">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>

	<bean id="reorderFollowedGroupIds"
		class="org.eurekastreams.server.persistence.mappers.stream.ReorderFollowedGroupIds">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="reorderStreamsDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.ReorderStreamsDbMapper">
	</bean>

	<bean id="getStarredActivityIds"
		class="org.eurekastreams.server.persistence.mappers.stream.GetStarredActivityIds">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="getLikedActivityIdsByUserId"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetLikedActivityIdsByUserIdsDbMapper" />
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="addCachedPersonFollower"
		class="org.eurekastreams.server.persistence.mappers.cache.AddCachedPersonFollower">
		<constructor-arg ref="getFollowedPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="addCachedGroupFollower"
		class="org.eurekastreams.server.persistence.mappers.cache.AddCachedGroupFollower">
		<constructor-arg ref="getFollowedGroupIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForGroupByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="insertActivityComment"
		class="org.eurekastreams.server.persistence.mappers.stream.InsertActivityComment">
		<constructor-arg ref="commentDTOPopulator" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="commentDTOPopulator"
		class="org.eurekastreams.server.persistence.mappers.cache.cachedfieldpopulators.CommentDTOPopulator">
		<constructor-arg ref="getPersonsByIdsMapper" />
	</bean>

	<bean id="getPersonIdsFollowingActivityDestinationStreamMapper"
		class="org.eurekastreams.server.persistence.mappers.GetPersonIdsFollowingActivityDestinationStreamMapper">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
	</bean>

	<bean id="postCachedActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.PostCachedActivity">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="getParentOrgIdsRecursiveByOrgIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getOrgShortNamesByIdsMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="postActivityUpdateStreamsByActorMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.PostActivityUpdateStreamsByActorMapper">
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />	
		<constructor-arg ref="getStreamScopeForResourceScopeTypeByUniqueKeyExceptionIfNotFound" />			
		<property name="cache" ref="memcachedCache" />
	</bean>
	
	<bean id="hideResourceActivityMapper" class="org.eurekastreams.server.persistence.mappers.db.HideResourceActivityMapper">            
        <property name="cache" ref="memcachedCache" />
    </bean>
	
    <bean id="hideResourceActivityCacheUpdateMapper" class="org.eurekastreams.server.persistence.mappers.cache.HideResourceActivityCacheUpdateMapper">
        <constructor-arg ref="activityDTOMapper" />
        <constructor-arg ref="getPersonByAccountIdMapper" />         
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />            
        <property name="cache" ref="memcachedCache" />
    </bean>

	<bean id="updateCachedOrganizationNameMapper"
		class="org.eurekastreams.server.persistence.UpdateCachedOrganizationName">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="gadgetUserPrefMapper"
		class="org.eurekastreams.server.persistence.mappers.opensocial.GetGadgetUserPrefMapper">
	</bean>
	
	<bean id="getRootOrganizationIdAndShortNameMapper"
		class="org.eurekastreams.server.persistence.mappers.GetRootOrganizationIdAndShortName" />

	<bean id="getPrivateGroupIdsCoordinatedByPersonMapper"
		class="org.eurekastreams.server.persistence.mappers.GetPrivateGroupIdsCoordinatedByPerson" />

	<!-- TODO: rename this bean -->
	<bean id="clearActivityStreamSearchStringCacheOnGroupUpdate"
		class="org.eurekastreams.server.persistence.mappers.cache.ClearPrivateGroupIdsViewableByCoordinatorCacheOnGroupUpdate">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<!-- TODO: rename this bean -->
	<bean id="clearActivityStreamSearchStringCacheOnOrgUpdate"
		class="org.eurekastreams.server.persistence.mappers.cache.ClearPrivateGroupIdsViewableByCoordinatorCacheOnOrgUpdate">
		<constructor-arg ref="getOrganizationCoordinatorIdsByOrganizationIdDbMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.GetPrivateCoordinatedAndFollowedGroupIdsForUser">
		<constructor-arg ref="getPrivateGroupsByUserId" />
		<constructor-arg ref="getFollowedGroupIdsForPersonByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="buildActivityStreamSearchStringForUserMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.BuildActivityStreamSearchStringForUser">
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
	</bean>

	<bean id="getActivityIdsAuthoredByOrOriginallyAuthoredByEntityDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsAuthoredByOrOriginallyAuthoredByEntity" />

	<bean id="getActivityCommentIdsAuthoredByPersonIdDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityCommentIdsAuthoredByPersonId" />

	<bean id="getActivityIdsWithFirstOrLastCommentsAuthoredByPersonIdDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsWithFirstOrLastCommentsAuthoredByPersonId" />

	<bean id="getCommentorIdsByActivityId"
		class="org.eurekastreams.server.persistence.mappers.db.GetCommentorIdsByActivityId" />

	<bean id="getTabPermissionByPersonAndTabMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetTabPermissionByPersonAndTab">
	</bean>

	<bean id="getNotificationFilterPreferencesByPersonId"
		class="org.eurekastreams.server.persistence.mappers.db.GetNotificationFilterPreferencesByPersonId" />

	<bean id="setUserNotificationFilterPreferences"
		class="org.eurekastreams.server.persistence.mappers.db.SetUserNotificationFilterPreferences" />

	<bean id="getNotificationFilterPreferencesByPeopleIds"
		class="org.eurekastreams.server.persistence.mappers.db.GetNotificationFilterPreferencesByPeopleIds" />

	<bean id="setAllApplicationAlertsAsReadByUserId"
		class="org.eurekastreams.server.persistence.mappers.db.SetAllApplicationAlertsAsReadByUserId" />

	<bean id="getApplicationAlertsByUserId"
		class="org.eurekastreams.server.persistence.mappers.db.GetApplicationAlertsByUserId" />

	<bean id="deleteApplicationAlertsByDate"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteApplicationAlertsByDate" />

	<bean id="getUserIdsWithUnreadApplicationAlertsByDate"
		class="org.eurekastreams.server.persistence.mappers.db.GetUserIdsWithUnreadApplicationAlertsByDate" />

	<bean id="getUnreadApplicationAlertCountByUserId" 
		class="org.eurekastreams.server.persistence.mappers.db.notification.GetUnreadApplicationAlertCountByUserId">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>
		
	<bean id="getCachedAlertCountByUserId" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
						<constructor-arg>
							<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
						</constructor-arg>
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg ref="getUnreadApplicationAlertCountByUserId" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg>
					<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
				</constructor-arg>
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>
	
	<bean id="getCachedAlertCountByUserId_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg ref="nullResultPartialMapper" />
		<!-- Database mapper -->
		<constructor-arg ref="getUnreadApplicationAlertCountByUserId" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg>
					<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
				</constructor-arg>
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>
	
	<bean id="populateOrgChildWithSkeletonParentOrgsCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.PopulateOrgChildWithSkeletonParentOrgsCacheMapper">
		<constructor-arg ref="getOrganizationsByIdsMapper" />
	</bean>

	<bean id="populatePeopleWithSkeletonRelatedOrgsCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.PopulatePeopleWithSkeletonRelatedOrgsCacheMapper">
		<constructor-arg ref="getOrganizationsByIdsMapper" />
		<constructor-arg ref="getPersonsByIdsMapper" />
	</bean>

	<bean id="deleteGroupActivity"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteGroupActivity" />

	<bean id="removeGroupFollowers"
		class="org.eurekastreams.server.persistence.mappers.db.RemoveGroupFollowers" />

	<bean id="deleteGroupSubscriptions"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteAllFeedSubscriberByEntityTypeAndId" />

	<bean id="deleteGroup"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteGroup">
		<constructor-arg ref="findByIdMapper" />
		<constructor-arg ref="jpaOrganizationMapper" />
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.domain.strategies.OrganizationHierarchyTraverserBuilder" />
		</constructor-arg>
		<constructor-arg ref="getParentOrgIdsRecursiveByOrgIdMapper" />
		<constructor-arg ref="getOrgShortNamesByIdsMapper" />
	</bean>

	<bean id="getRelatedOrganizationIdsByPersonId"
		class="org.eurekastreams.server.persistence.mappers.GetRelatedOrganizationIdsByPersonId" />

	<bean id="updateActivityFlagMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.UpdateActivityFlag" />

	<bean id="getFlaggedActivitiesForOrganizationMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetFlaggedActivitiesForOrganization">
		<constructor-arg ref="bulkActivitiesMapper" />
	</bean>

	<bean id="getExpiredActivities"
		class="org.eurekastreams.server.persistence.mappers.db.GetExpiredActivities" />

	<bean id="removeExpiredActivities"
		class="org.eurekastreams.server.persistence.mappers.cache.RemoveExpiredActivities">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="removeIdsFromLists"
		class="org.eurekastreams.server.persistence.mappers.cache.RemoveIdsFromLists">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteSystemSettingsCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.DeleteSystemSettingsCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteCacheKeys"
		class="org.eurekastreams.server.persistence.mappers.cache.DeleteCacheKeys">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteFromSearchIndex"
		class="org.eurekastreams.server.persistence.mappers.DeleteFromSearchIndex" />

	<bean id="updateNotificationsOnNameChangeMapper"
		class="org.eurekastreams.server.persistence.mappers.db.UpdateNotificationsOnNameChangeMapper" />

    <bean id="updatePersonMapper"
        class="org.eurekastreams.server.persistence.mappers.db.UpdatePersonMapper" />
        
	<bean id="indexEntity"
		class="org.eurekastreams.server.persistence.mappers.IndexEntity" />


	<bean id="getPeopleWhoLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg ref="CacheKeys.LIKERS_BY_ACTIVITY_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedActivityDbMapper" />
		</constructor-arg>
		<constructor-arg ref="collectionCombiner" />
		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg ref="CacheKeys.LIKERS_BY_ACTIVITY_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getPeopleWhoLikedResource"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg ref="CacheKeys.LIKERS_BY_RESOURCE_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedResourceDbMapper" />
		</constructor-arg>
		<constructor-arg ref="collectionCombiner" />
		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg ref="CacheKeys.LIKERS_BY_RESOURCE_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<!-- Begin ldap mappers -->

	<bean id="findLdapGroupByCnNameMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findLdapGroupByCnFilter" />
		<constructor-arg ref="ldapToLdapGroupCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findLdapGroupByLdapGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="ldapGroupDnLdapTemplateRetriever" />
		<constructor-arg ref="findLdapGroupByMembershipFilter" />
		<constructor-arg ref="ldapToLdapGroupCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findPersonByProvidedLdapQueryMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByAttributeQueryFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findPersonByCnWildcardMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByCnWildcardFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>
	
    <bean id="findPersonByAccountIdMapper"
        class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
        <constructor-arg ref="searchStringLdapTemplateRetriever" />
        <constructor-arg ref="findPersonByAccountIdFilter" />
        <constructor-arg ref="ldapToPersonCallbackFactory" />
        <constructor-arg ref="pagedLdapSearchStrategy" />
    </bean>	

	<bean id="findPersonByDirectLdapGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="ldapGroupDnLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByMembershipFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<!-- End ldap mappers -->
	
	<bean id="getPeopleSkillsByPeopleIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSkillsAndInterestsByEmployeeIdsDbMapper" />
	
    <bean id="deleteOrganizationMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteOrganizationDbMapper" >
        <constructor-arg ref="findByIdMapper"/>
    </bean>
    
    <bean id="getPersonIds" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="Person"/>
        <constructor-arg value="id"/>        
    </bean>
    
    <bean id="getGroupIds" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="DomainGroup"/>
        <constructor-arg value="id"/>        
    </bean> 
    
    <bean id="getOrganizationIds" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="Organization"/>
        <constructor-arg value="id"/>        
    </bean>  
    
    <bean id="getThemeUuidsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="Theme"/>
        <constructor-arg value="uuid"/>        
    </bean>             
    
    <bean id="getPersonsByIdsDBMapper" class="org.eurekastreams.server.persistence.mappers.db.GetPersonsByIds">
        <constructor-arg ref="personQueryStrategy" />
        <constructor-arg ref="getRelatedOrganizationIdsByPersonId" />
        <constructor-arg ref="getOrganizationsByIdsMapper" />
        <constructor-arg ref="getPeopleSkillsByPeopleIdsDbMapper" />
    </bean>  
    
    <bean id="getGroupsByIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetGroupsByIdsDbMapper">
        <constructor-arg ref="domainGroupQueryStrategy" />
    </bean>
    
    <bean id="deleteThemeByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteEntityByIdDbMapper">
        <constructor-arg value="org.eurekastreams.server.domain.Theme" />
    </bean>
    
    <bean id="deleteAndReorderStreamsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteAndReorderStreamsDbMapper"/>
        
    <bean id="getPeopleIdsUsingThemeByThemeId" class="org.eurekastreams.server.persistence.mappers.db.GetPeopleIdsUsingThemeByThemeId"/>
    
    <bean id="getThemeXmlUrlByUuidDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetThemeXmlUrlByUuidDbMapper"/>
    
    <bean id="getOrderedCommentIdsByActivityIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetOrderedCommentIdsByActivityIdDbMapper" />
    
    <bean id="getAllOrganizationIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetAllOrganizationIdsDbMapper" />
    
    <bean id="getOrganizationsByIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetOrganizationsByIdsDbMapper" />
    
    <bean id="getParentOrgIdsRecursiveByOrgIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetParentOrgIdsRecursiveByOrgIdDbMapper" />
    
    <bean id="getChildOrgIdsRecursiveByOrgIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetChildOrgIdsRecursiveByOrgIdDbMapper" />
      
    <bean id="getGroupCoordinatorIdsByGroupIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetGroupCoordinatorIdsByGroupIdDbMapper" />
    
    <bean id="getFollowedGroupIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowedGroupIdsForPersonByIdDbMapper" />
    
    <bean id="getFollowerPersonIdsForGroupByIdWithActivityNotificationsDbMapper" 
        class="org.eurekastreams.server.persistence.mappers.db.GetFollowerPersonIdsForGroupByIdWithActivityNotificationsDbMapper" />
    
    <bean id="getFollowerPersonIdsForGroupByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowerPersonIdsForGroupByIdDbMapper" />    
    
    <bean id="getFollowerPersonIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowerPersonIdsForPersonByIdDbMapper" />
    
    <bean id="getFollowedPersonIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowedPersonIdsForPersonByIdDbMapper" />      
    
    <bean id="getRelatedEntityCountMapper" class="org.eurekastreams.server.persistence.mappers.db.GetRelatedEntityCount" />
	
	<bean id="moveOrganizationPeopleMapper" class="org.eurekastreams.server.persistence.mappers.db.MoveOrganizationPeopleDBMapper" />
	
	<bean id="getListsContainingActivities" class="org.eurekastreams.server.persistence.mappers.db.GetListsContainingActivities">
		<constructor-arg ref="getParentOrgIdsRecursiveByOrgIdMapper" />
        <constructor-arg ref="getOrgShortNamesByIdsMapper" />
	</bean>
	
	<bean id="getPeopleIdsWithRelatedOrg" class="org.eurekastreams.server.persistence.mappers.db.GetPeopleIdsWithRelatedOrg" />
	
	<bean id="syncParentOrgForGroupActivities" class="org.eurekastreams.server.persistence.mappers.db.SyncParentOrgForGroupActivities" />
	
	<bean id="getActivityIdsPostedToStreamByUniqueKeyAndScopeType" 
	    class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsPostedToStreamByUniqueKeyAndScopeType" />                

	<bean id="insertRequestForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.InsertRequestForGroupMembership" />

	<bean id="deleteRequestForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteRequestForGroupMembership" />

	<bean id="getRequestsForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetRequestsForGroupMembershipByGroup" />

	<bean id="updateGadgetsWithNewTabLayoutMapper"
		class="org.eurekastreams.server.persistence.mappers.db.UpdateGadgetsWithNewTabLayoutMapper" />

	<bean id="getOrganizationProxyById"
		class="org.eurekastreams.server.persistence.mappers.db.GetOrganizationProxyById" />

	<bean id="getPersonIdsByLockedStatus"
		class="org.eurekastreams.server.persistence.mappers.db.GetPersonIdsByLockedStatus" />

	<bean id="setPersonLockedStatus"
		class="org.eurekastreams.server.persistence.mappers.db.SetPersonLockedStatus" />

	<bean id="increaseOrgEmployeeCount"
		class="org.eurekastreams.server.persistence.mappers.db.IncreaseOrgEmployeeCount" />
		
	<bean id="getOrgShortNamesByIdsMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetOrgShortNamesByIdsMapper" />
		
	<bean id="getReadOnlyStreamsDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetReadOnlyStreamsDbMapper" />
    
    <bean id="getPersonAdditionalProperties" class="org.eurekastreams.server.persistence.mappers.db.GetAllPersonAdditionalProperties" />

    <bean id="changeGroupActivitySubscriptionDbMapper" class="org.eurekastreams.server.persistence.mappers.db.ChangeGroupActivitySubscriptionDbMapper" />
    
    <bean id="findOrInsertSharedResourceByUniqueKeyMapper" class="org.eurekastreams.server.persistence.mappers.db.FindOrInsertSharedResourceByUniqueKeyDbMapper" />
    
    <bean id="setLikedSharedResourceStatusDbMapper" class="org.eurekastreams.server.persistence.mappers.db.SetLikedSharedResourceStatusDbMapper" />
        
    <!-- Metrics -->
    <bean id="getUsageMetricSummaryDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetUsageMetricSummaryDbMapper" />
    <bean id="getDailyMessageCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyMessageCountDbMapper" />
    <bean id="getDailyMessageResponseTime" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyMessageResponseTime" />
    <bean id="getDailyPageViewCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyPageViewCountDbMapper" />
    <bean id="getDailyStreamContributorCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamContributorCountDbMapper" />
    <bean id="getDailyStreamViewCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamViewCountDbMapper" />
    <bean id="getDailyStreamViewerCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamViewerCountDbMapper" />
    <bean id="getDailyUniqueVisitorCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyUniqueVisitorCountDbMapper" />
    <bean id="getDailyUsageSummaryByDateDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyUsageSummaryByDateDbMapper" />
    <!-- END Metrics -->
    
    <bean id="dayOfWeekStrategy" class="org.eurekastreams.commons.date.DayOfWeekStrategy" />
    <bean id="getDateFromDaysAgoStrategy" class="org.eurekastreams.commons.date.GetDateFromDaysAgoStrategy" />
    
    <bean id="personModelViewAvatarDisplayTransformer" class="org.eurekastreams.server.domain.strategies.PersonModelViewAvatarDisplayTransformer"/>
    
    <!-- Mapper to get PersonModelViews with only the information needed to display avatars -->
    <bean id="getPersonAvatarDisplayInfoByIdsMapper" class="org.eurekastreams.server.persistence.mappers.DomainMapperTransformer">
        <constructor-arg ref="getPersonsByIdsMapper" />
        <constructor-arg ref="personModelViewAvatarDisplayTransformer" />
    </bean>
    
    <bean id="sharedResourceRequestToUniqueKeyTransformer" class="org.eurekastreams.server.persistence.mappers.cache.SharedResourceRequestToUniqueKeyTransformer" />
    <bean id="getSharedResourceByKeyDBMapper" class="org.eurekastreams.server.persistence.mappers.GetSharedResourcePropertiesMapper">
        <constructor-arg ref="getStreamScopeForResourceScopeTypeByUniqueKey" />
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoSharedResourceDbMapper" />
        </constructor-arg>
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedResourceDbMapper" />
        </constructor-arg>
    </bean>
    <!-- 
        Mapper to get the cacheable components of a SharedResourceDTO, which is everything except whether the current person liked it, and does not include
        any avatar info for the people that liked it.
     -->
    <bean id="getSharedResourceByKeyMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
               <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg>
                            <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SHARED_RESOURCE_BY_UNIQUE_KEY" />
                        </constructor-arg>
                        <constructor-arg ref="sharedResourceRequestToUniqueKeyTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper -->
        <constructor-arg ref="getSharedResourceByKeyDBMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SHARED_RESOURCE_BY_UNIQUE_KEY" />
                </constructor-arg>
                <constructor-arg ref="sharedResourceRequestToUniqueKeyTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>
    
    <!-- gets single streamScopeId for resource based on StreamScope uniqueKey, returns null if exactly one result not found. -->
    <bean id="getStreamScopeForResourceScopeTypeByUniqueKey" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">RESOURCE</value>
        </constructor-arg>
        <constructor-arg value="false" />
    </bean>
    
    <!-- gets single streamScopeId for resource based on StreamScope uniqueKey, throws exception if exactly one result not found. -->
    <bean id="getStreamScopeForResourceScopeTypeByUniqueKeyExceptionIfNotFound" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">RESOURCE</value>
        </constructor-arg>
        <constructor-arg value="true" />
    </bean>
    
    <!-- gets single activityDTO by id, returns null if exactly one result not found. -->
    <bean id="activityDTOMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="bulkActivitiesMapper" />
        <constructor-arg value="false" />
    </bean>
    
</beans>
