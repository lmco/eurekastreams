## Overview

Notifications are sent by calling an async action whenever an "event" occurs, typically done inside another action such as PostActivityComment. A single system event may require multiple notifications to be sent, and the flavors required may depend on rules or dynamic runtime conditions. (For example, commenting on an activity sends different notifications to the stream owner, the author of the activity, and any other people who commented, but should not notify the person making the comment.) To handle this, Translators are defined for each event type and are responsible for generating the appropriate list of notifications for that particular event. These are wired up by Spring. These translators choose from the enumeration NotificationType when determining which notifications to generate. Notifications themselves are transport- and medium-agnostic - they only contain the data itself. Notifiers are responsible for sending a notification on a specific medium, such as email. One or more Notifiers are defined in a Spring configuration file and are responsible for sending notifications for each NotificationType that a Translator returns.

The high-level flow looks as follows:

![](images/NF_EurekaNotifications-diagram1.png)

The most complex NotificationTranslator by far is the CommentTranslator. Distinct notifications need to be sent when someone comments on a post you made, comments to a post in your stream, and also comments on something you have also commented on. To manage this complexity, the CommentTranslator uses a mapper (GetPeopleToNotifyForComment) to find the users appropriate for each comment case.

The GenerateNotificationsAction class itself glues everything together by determining what the event was and retreiving the appropriate Translator (the system event is represented by a RequestType enumeration within the GenerateNotificationRequest). This Translator then returns a collection of NotificationDTO objects, each with a specific NotificationType and list of recipients. Finally, the action loops over each Notifier to send each NotificationDTO.

Currently, we define an EmailNotifier and an ApplicationAlertNotifier. The goal of the EmailNotifier is obviously simple. The ApplicationAlertNotifier stores the necessary notification metadata in a Eureka Streams database table for display by the UI. The entity used for this is ApplicationAlertNotification.

![](images/NF_Notifications-Class-Diagram.jpg)

## Email Design / Implementation

Email sending is handled asynchronously to allow:

1. Delays interacting with email servers to not hold up GenerateNotificationsAction.
2. When coupled with an appropriate queuing mechanism, allows emails which failed to send to be re-queued and tried again.

Email sending plugs into the flow with a Notifier. The AsyncNotifier is used, which queues a SendNotificationRequest asynchronously to the SendEmailNotificationAction. This action builds the email then sends it. The email is built by invoking an email builder (which implements NotificationEmailBuilder) specific to the type of notification. The list of email builders is injected via Spring, and as of this writing consists of multiple instances of TemplateEmailBuilder.

The conceptual flow is:

![](images/NF_EurekaNotifications-diagram2.png)

SendEmailNotificationAction swallows exceptions relating to building an email, but passes out ones relating to sending. This is so that a failure to build an email does not cause a retry, but a failure to send will.

TemplateEmailBuilder constructs an email using configured template strings for the subject, text body, and HTML body. The text and HTML forms of the body are separate templates so that both forms can be designed specifically to look good; automatic conversion from HTML to text or vice versa would yield an ugly / sub-optimal message in the generated format. Dynamic content is handled by placing named parameters in the template which are replaced by the actual values using the Apache Commons Lang class StrSubstitutor. Should more advanced template processing be desired, Apache Velocity could be used. The actual text of the templates is provided as constructor arguments and currently is specified directly in the Spring configuration file. If desired, a bean could be written to read the templates from a file using Spring resource management.